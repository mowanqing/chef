## fluentd详解

[toc]
### 配置文件的语法

配置文件位置：

```shell
/etc/td-agent/td-agent.conf
```

指令列表：

1. source
   - 决定输入源
2. match
   - 决定输出目的地
3. filter
   - 决定事件处理管道
4. system
   - 设置系统范围的配置
5. label
   - 作为内部路由对输出和过滤器进行分组
6. @include
   - 包括其他文件

### source：这些数据从何而来

通过使用源指令选择和配置所需的输入插件，可以启用Fluentd输入源。

Fluentd标准输入插件包括**http**和**forward**。

- http提供一个http端点来接受传入的http消息。

- forward提供一个TCP端点来接受TCP数据包。

当然，这两者也可以同时进行。您可以根据需要添加多个源配置。

```shell
# Receive events from 24224/tcp
# This is used by log forwarding and the fluent-cat command
<source>
  @type forward
  port 24224
</source>

# http://<ip>:9880/myapp.access?json={"event":"data"}
<source>
  @type http
  port 9880
</source>
```

每个source指令必须包含一个@type参数来指定要使用的输入插件。

### Routing

source将事件提交给Fluentd路由引擎。

一个事件由三个实体组成:**tag**、**time** 和**record**。

- **tag**是一个由点分隔的字符串(例如myapp.access)，用作Fluentd内部路由引擎的方向。

- **time**字段由输入插件指定，且必须为Unix时间格式。
- **record**是一个JSON对象。

> Fluentd接受所有非句号字符作为标记的一部分。然而，由于标签有时会在不同的上下文中被输出目的地使用(例如表名、数据库名、键名等)，**因此强烈建议您坚持使用小写字母、数字和下划线**(例如^[a-z0-9_]+$)。

在前面的例子中，HTTP输入插件提交了以下事件:

```shell
# generated by http://<ip>:9880/myapp.access?json={"event":"data"}
tag: myapp.access
time: (current time)
record: {"event":"data"}
```

### match:告诉fluentd要做什么!

**match**指令查找带有匹配**tags**的事件并处理它们。match指令最常见的用法是将事件输出到其他系统。由于这个原因，与match指令对应的插件被称为**输出插件**。Fluentd标准输出插件包括**file**和**forward**。让我们将这些添加到配置文件中。

```shell
# Receive events from 24224/tcp
# This is used by log forwarding and the fluent-cat command
<source>
  @type forward
  port 24224
</source>

# http://<ip>:9880/myapp.access?json={"event":"data"}
<source>
  @type http
  port 9880
</source>

# Match events tagged with "myapp.access" and
# store them to /var/log/fluent/access.%Y-%m-%d
# Of course, you can control how you partition your data
# with the time_slice_format option.
<match myapp.access>
  @type file
  path /var/log/fluent/access
</match>
```

每个**match**指令必须包含一个匹配模式和一个@type参数。只有带有与模式匹配的**tag**事件才会被发送到输出目的地(在上面的示例中，只有带有标记**myapp.access**的事件才会匹配。**@type**参数指定要使用的输出插件。

### filter:事件处理管道

**filter**指令具有与match相同的语法，但是filter可以被链接用于处理管道。使用**filters**，事件流是这样的:

```shell
Input -> filter 1 -> ... -> filter N -> Output
```







